N = int(input())
weight = list(map(int,input().split()))
value = list(map(int,input().split()))
# 편의상 체력소모를 무게로, 기쁨을 가치로 부르겠음
dp = [0 for i in range(100)] # index는 최대무게까지

for i in range(N):
    if weight[i]<100: # 해당 가방에 넣을 무게가 현재 최대 무게보다 작아야한다.
        for j in range(100-1,-1,-1): # 이 핵심 반복문은 뒤에서부터 도는데 그래야 엉뚱하게 동일한
                                        # 무게를 넣지 않는다
            if dp[j] and weight[i] + j < 100: # 다음에 짐을 넣을 건데 '그 전에 어떤 짐이라도 짐이 들어있는지'
                # 해당 짐을 넣으면 최대 무게는 넘지 않는지 체크
                dp[j + weight[i]] = max(dp[j+weight[i]], dp[j]+value[i]) # 짐을 넣어서 가치를 갱신

        dp[weight[i]]=max(dp[weight[i]],value[i]) # 달랑 이것만 넣었을 때를 체크, 제일 첫번째
                                                    # 반복문에서의 이 코드는 첫번쨰 물건을 넣음을 의미한다.
print(max(dp))

# 배낭문제는 난 개인적으로 많이 싫어한다 아직까지도 완벽하게는 이해를 못했다.
# 다만 경우의 수를 체크하면서 또, 세영누나에게 팁을 들으면서 감은 잡혔다.
# 일단 배낭문제는 물건이 n개 있다면 최대 2의 n제곱의 경우의 수를 무식하게 따지면
# 된다는 걸 알지만, 갯수가 많아질수록 지수함수적으로 망한다
# 위의 방법에서 중요한 포인트는 꼴랑 저 몇줄 만으로 진짜로
# 유효한 모든 경우의 수를 확인해본다는 것이다.
# 약간 평행우주처럼 생각해보면 좋겠다.
# 만일 저 dp 배열에 핵심 반복문을 돌면 어떤 물건이 들어간 배열이 있고, 안들어간 배열이 있다.
# 그럼 거기서부터 가지치기가 되는 것이다. 해당 히스토리를 끝까지 들고 가는것
# '저런 간단한 코드로 어떤 짐은 안들어 갈 것같다 ㅠㅠ' 이런생각을 가지지 않아도 된다.
